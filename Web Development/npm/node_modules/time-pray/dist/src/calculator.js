"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPrayerCalculator = void 0;
const sunPosition_1 = require("./utils/sunPosition");
const toJulianDate_1 = require("./utils/toJulianDate");
const DMath = __importStar(require("./utils/degree-math"));
const numbers_1 = require("./utils/numbers");
const getPrayerCalculator = (settings) => (location, date) => {
    const julianDate = (0, toJulianDate_1.toJulianDate)(date, location);
    return {
        dhuhr: toDate(dhuhr()),
        sunset: toDate(sunset()),
        sunrise: toDate(sunrise()),
        asr: toDate(asr()),
        fajr: toDate(fajr()),
        imsak: toDate(imsak()),
        maghrib: toDate(maghrib()),
        isha: toDate(isha()),
        midnight: toDate(midnight()),
    };
    function asr() {
        return asrTime(settings.asr.factor, 13 / 24);
    }
    function dhuhr() {
        return midDay(12 / 24) + settings.dhuhr.minutes / 60;
    }
    function midnight() {
        return (sunset() +
            timeDifference(sunset(), settings.midnight == "Jafari" ? fajr() : sunrise()) /
                2);
    }
    function isMinutes(s) {
        return !!s && "minutes" in s;
    }
    function isha() {
        if (isMinutes(settings.isha)) {
            return maghrib() + settings.isha.minutes / 60;
        }
        const angle = settings.isha.degree;
        const time = midDay(18 / 24) + SAT(18 / 24, angle);
        if (hlAdjustmentNeeded(time, sunset(), angle)) {
            return sunset() + nightPortion(angle);
        }
        return time;
    }
    function maghrib() {
        if (isMinutes(settings.maghrib)) {
            return sunset() + settings.maghrib.minutes / 60;
        }
        const angle = settings.maghrib.degree;
        const time = midDay(18 / 24) + SAT(18 / 24, angle);
        if (hlAdjustmentNeeded(time, sunset(), angle)) {
            return sunset() + nightPortion(angle);
        }
        return time;
    }
    function imsak() {
        if (isMinutes(settings.imsak)) {
            return fajr() - settings.imsak.minutes / 60;
        }
        const angle = settings.imsak.degree;
        const time = midDay(5 / 24) - SAT(5 / 24, angle);
        if (hlAdjustmentNeeded(time, sunrise(), angle)) {
            return sunrise() - nightPortion(angle);
        }
        return time;
    }
    function fajr() {
        const angle = settings.fajr.degree;
        const time = midDay(5 / 24) - SAT(5 / 24, angle);
        if (hlAdjustmentNeeded(time, sunrise(), angle)) {
            return sunrise() - nightPortion(angle);
        }
        return time;
    }
    function sunset() {
        return midDay(18 / 24) + SAT(18 / 24, riseSetAngle());
    }
    function sunrise() {
        return midDay(6 / 24) - SAT(6 / 24, riseSetAngle());
    }
    function nightTime() {
        return timeDifference(sunset(), sunrise());
    }
    //---------------------- Calculation Functions -----------------------
    // compute mid-day time
    function midDay(time) {
        const eqt = (0, sunPosition_1.sunPosition)(julianDate + time).equation;
        const noon = (0, numbers_1.fixHour)(12 - eqt) - location.longitude / 15;
        return noon;
    }
    function SAT(time, angle) {
        const decl = (0, sunPosition_1.sunPosition)(julianDate + time).declination;
        return ((1 / 15) *
            DMath.arccos((-DMath.sin(angle) -
                DMath.sin(decl) * DMath.sin(location.latitude)) /
                (DMath.cos(decl) * DMath.cos(location.latitude))));
    }
    // compute the time at which sun reaches a specific angle below horizon
    // compute asr time
    function asrTime(factor, time) {
        const decl = (0, sunPosition_1.sunPosition)(julianDate + time).declination;
        const angle = -DMath.arccot(factor + DMath.tan(Math.abs(location.latitude - decl)));
        return midDay(time) + SAT(time, angle);
    }
    //---------------------- Compute Prayer Times -----------------------
    // return sun angle for sunset/sunrise
    function riseSetAngle() {
        //var earthRad = 6371009; // in meters
        //var angle = DMath.arccos(earthRad/(earthRad+ elv));
        const angle = 0.0347 * Math.sqrt(location.elevation || 0); // an approximation
        return 0.833 + angle;
    }
    // adjust a time for higher latitudes
    function hlAdjustmentNeeded(time, base, angle) {
        const portion = nightPortion(angle);
        const timeDiff = Math.abs(time - base);
        return (settings.highLats != "None" &&
            (isNaN(time) || timeDiff > portion));
    }
    // the night portion used for adjusting times in higher latitudes
    function nightPortion(angle) {
        const night = nightTime();
        const method = settings.highLats;
        let portion = 1 / 2; // MidNight
        if (method == "AngleBased")
            portion = (1 / 60) * angle;
        if (method == "OneSeventh")
            portion = 1 / 7;
        return portion * night;
    }
    // compute the difference between two times
    function timeDifference(time1, time2) {
        return (0, numbers_1.fixHour)(time2 - time1);
    }
    function toDate(hours) {
        if (isNaN(hours)) {
            return new Date(NaN);
        }
        return new Date(Date.UTC(date[0], date[1] - 1, date[2]) + hours * 3600 * 1000);
    }
};
exports.getPrayerCalculator = getPrayerCalculator;
//# sourceMappingURL=calculator.js.map